# Agent Identity & Manifest Specification (A2A v1.0)\n\n## Decentralized Identifiers (DIDs)\n\nEvery agent MUST have a globally unique, cryptographically verifiable identifier.\n\n### did:key (Self-Signed)\n\nFormat: `did:key:z6Mk<base58-encoded-public-key>`\n\n**Advantages:**\n- Self-sovereign (no external service required)\n- Offline verifiable (public key embedded in DID)\n- Portable (can be used anywhere)\n\n**Generation:**\n```python\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\nimport base58\n\nprivate_key = ed25519.Ed25519PrivateKey.generate()\npublic_key = private_key.public_key()\npublic_key_bytes = public_key.public_bytes_raw()\n\n# Encode: z = base58 indicator, 6Mk = multicodec for Ed25519 public key\nmulticodec_bytes = bytes([0x12, 0x20]) + public_key_bytes  # 0x1220 = Ed25519 pub key\ndid = \"did:key:z\" + base58.b58encode(multicodec_bytes).decode()\n# Result: did:key:z6MkiTBz1ymuqzVvQ9nsfRVnQKNJsXvW7dXbEKVTMj1Jzh7t\n```\n\n**Resolution (no network call):**\n```python\ndef resolve_did_key(did: str) -> PublicKey:\n    # Extract base58 portion\n    b58_part = did.replace(\"did:key:z\", \"\")\n    \n    # Decode from base58\n    multicodec_bytes = base58.b58decode(\"z\" + b58_part)\n    \n    # Extract public key (skip multicodec prefix)\n    public_key_bytes = multicodec_bytes[2:]\n    \n    return ed25519.Ed25519PublicKey.from_public_bytes(public_key_bytes)\n```\n\n### did:web (DNS-Backed)\n\nFormat: `did:web:<domain>[:<path>]:<agent-id>`\n\nExample: `did:web:example.com:agents:translator`\n\n**Resolution:**\n```\nGET https://example.com/.well-known/did.json\n\n# or with path:\nGET https://example.com/agents/.well-known/did.json\n```\n\n**Response:**\n```json\n{\n  \"agent_did\": \"did:web:example.com:agents:translator\",\n  \"public_keys\": [...],\n  \"endpoints\": [...]\n}\n```\n\n**Advantages:**\n- Tied to domain (organization identity)\n- Can revoke/rotate keys at domain level\n- DNS-backed trust model\n\n**Disadvantages:**\n- Requires DNS resolution and HTTPS\n- Dependent on domain registration\n\n### did:github (GitHub-Backed)\n\nFormat: `did:github:<owner>/<repo>`\n\nExample: `did:github:anthropic/a2a-reference`\n\n**Resolution:**\n```\n1. Fetch manifest: GET https://raw.githubusercontent.com/anthropic/a2a-reference/main/.well-known/agent-manifest.json\n2. Verify repo ownership: GitHub API check\n3. Extract public key from manifest\n```\n\n**Advantages:**\n- Leverages existing GitHub identity/reputation\n- Can use GitHub stars, forks, activity as trust signals\n- Source code can be published alongside\n\n**Disadvantages:**\n- Dependent on GitHub API\n- Must sign with key matching committed manifest\n\n---\n\n## Agent Manifest (Agent Card) JSON Schema\n\n```json\n{\n  \"$schema\": \"https://a2a.protocol/schema/manifest/1.0.json\",\n  \"manifest_version\": \"1.0\",\n  \"agent_did\": \"did:key:z6Mk...\",\n  \"agent_id\": \"translator-v1\",\n  \"name\": \"Anthropic Translator\",\n  \"description\": \"Translates text between 100+ languages\",\n  \"public_keys\": [\n    {\n      \"kid\": \"sig-2024-01\",\n      \"kty\": \"EC\",\n      \"alg\": \"EdDSA\",\n      \"use\": \"sig\",\n      \"key\": \"base64url_encoded_public_key\"\n    }\n  ],\n  \"endpoints\": [\n    {\n      \"type\": \"handshake\",\n      \"url\": \"https://api.example.com/a2a/handshake\",\n      \"transport\": \"http\",\n      \"auth_required\": true\n    },\n    {\n      \"type\": \"request\",\n      \"url\": \"https://api.example.com/a2a/request\",\n      \"transport\": \"http\",\n      \"auth_required\": true\n    }\n  ],\n  \"capabilities\": [\n    {\n      \"id\": \"nlp.translate\",\n      \"version\": \"1.0.0\",\n      \"description\": \"Translate text between languages\",\n      \"requires_capabilities\": []\n    },\n    {\n      \"id\": \"nlp.language_detect\",\n      \"version\": \"1.0.0\",\n      \"description\": \"Detect language of text\",\n      \"requires_capabilities\": []\n    }\n  ],\n  \"policy\": {\n    \"rate_limit\": 10000,\n    \"rate_period\": 3600,\n    \"session_timeout\": 3600,\n    \"max_payload_size\": 10485760,\n    \"data_retention\": \"24h\",\n    \"require_encryption\": false,\n    \"max_concurrent_sessions\": 1000\n  },\n  \"trust_chain\": [\n    {\n      \"issuer\": \"did:web:verified-agents.example.com\",\n      \"issued_at\": 1707244800,\n      \"expires_at\": 1708849600,\n      \"trust_level\": \"verified\",\n      \"signature\": \"jws_signature\"\n    }\n  ],\n  \"metadata\": {\n    \"organization\": \"Anthropic\",\n    \"support_email\": \"support@anthropic.com\",\n    \"source_code\": \"https://github.com/anthropic/a2a-reference\",\n    \"version_info\": {\n      \"protocol_version\": \"1.0\",\n      \"sdk_version\": \"1.0.0\",\n      \"build_date\": \"2026-02-07\"\n    }\n  },\n  \"published_at\": 1707244800,\n  \"expires_at\": null,\n  \"manifest_hash\": \"sha256:abc123def456...\",\n  \"manifest_signature\": \"eyJ...jws_signed_manifest\"\n}\n```\n\n---\n\n## Field Definitions\n\n### Required Fields\n\n- **manifest_version**: \"1.0\"\n- **agent_did**: Valid DID (did:key, did:web, or did:github)\n- **agent_id**: Human-readable ID (for display, not security)\n- **public_keys**: Array of JWK public keys (min 1, max 10)\n  - kid: Key identifier (for rotation)\n  - kty: \"EC\" (only EdDSA supported in v1.0)\n  - alg: \"EdDSA\"\n  - use: \"sig\" (signature only in v1.0)\n  - key: Base64url-encoded public key bytes\n- **endpoints**: Array of contact points (min 1)\n  - type: \"handshake\" or \"request\"\n  - url: Full HTTPS URL\n  - transport: \"http\" (required in v1.0)\n  - auth_required: Boolean\n- **manifest_hash**: SHA256 hash of canonical manifest (excluding signature)\n- **manifest_signature**: JWS signature over manifest\n\n### Recommended Fields\n\n- **name**: Human-readable agent name\n- **description**: What the agent does\n- **capabilities**: List of declared abilities\n- **policy**: Agent's constraints and limits\n- **published_at**: When manifest was published\n\n### Optional Fields\n\n- **expires_at**: When manifest expires (null = never)\n- **trust_chain**: Endorsements by other trusted agents\n- **metadata**: Custom fields (must be ignored by unknown clients)\n\n---\n\n## Manifest Signing & Verification\n\n### Signing Process\n\n```python\nimport json\nimport hashlib\nfrom cryptography.hazmat.primitives import serialization, hashes\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\nimport base64\nimport time\n\n# 1. Create manifest without signature\nmanifest = {\n    \"manifest_version\": \"1.0\",\n    \"agent_did\": \"did:key:z6Mk...\",\n    # ... all fields except manifest_hash and manifest_signature\n}\n\n# 2. Canonicalize (sort keys, remove whitespace)\ncanonical_json = json.dumps(manifest, sort_keys=True, separators=(',', ':'))\n\n# 3. Compute hash\nmanifest_hash = hashlib.sha256(canonical_json.encode()).hexdigest()\nmanifest['manifest_hash'] = f\"sha256:{manifest_hash}\"\n\n# 4. Create payload for JWS\npayload = {\n    \"manifest\": manifest,\n    \"manifest_hash\": manifest['manifest_hash'],\n    \"timestamp\": int(time.time()),\n    \"issuer\": manifest['agent_did']\n}\npayload_bytes = json.dumps(payload, separators=(',', ':')).encode()\n\n# 5. Create JWS\nheader = {\"alg\": \"EdDSA\", \"typ\": \"JWT\", \"kid\": \"sig-2024-01\"}\nheader_bytes = json.dumps(header, separators=(',', ':')).encode()\nheader_b64 = base64.urlsafe_b64encode(header_bytes).decode().rstrip('=')\npayload_b64 = base64.urlsafe_b64encode(payload_bytes).decode().rstrip('=')\n\n# 6. Sign\nsigning_input = f\"{header_b64}.{payload_b64}\".encode()\nsignature = private_key.sign(signing_input)\nsignature_b64 = base64.urlsafe_b64encode(signature).decode().rstrip('=')\n\n# 7. Assemble JWS\njws = f\"{header_b64}.{payload_b64}.{signature_b64}\"\nmanifest['manifest_signature'] = jws\n\nprint(json.dumps(manifest, indent=2))\n```\n\n### Verification Process\n\n```python\ndef verify_manifest(manifest: dict) -> bool:\n    \"\"\"\n    Verify manifest integrity and signature.\n    \"\"\"\n    # 1. Extract signature\n    jws = manifest['manifest_signature']\n    parts = jws.split('.')\n    if len(parts) != 3:\n        return False\n    \n    header_b64, payload_b64, signature_b64 = parts\n    \n    # 2. Decode (add padding as needed)\n    def b64_decode(s):\n        padding = '=' * (4 - len(s) % 4)\n        return base64.urlsafe_b64decode(s + padding)\n    \n    header = json.loads(b64_decode(header_b64))\n    payload = json.loads(b64_decode(payload_b64))\n    signature = b64_decode(signature_b64)\n    \n    # 3. Verify timestamp is recent\n    if abs(time.time() - payload['timestamp']) > 86400:\n        return False  # Manifest older than 24 hours\n    \n    # 4. Resolve public key from DID\n    did = manifest['agent_did']\n    public_key = resolve_did(did)\n    \n    # 5. Verify JWS signature\n    signing_input = f\"{header_b64}.{payload_b64}\".encode()\n    try:\n        public_key.verify(signature, signing_input)\n    except Exception:\n        return False\n    \n    # 6. Verify manifest hash\n    manifest_copy = manifest.copy()\n    del manifest_copy['manifest_signature']\n    canonical_json = json.dumps(manifest_copy, sort_keys=True, separators=(',', ':'))\n    computed_hash = f\"sha256:{hashlib.sha256(canonical_json.encode()).hexdigest()}\"\n    if computed_hash != manifest['manifest_hash']:\n        return False\n    \n    return True\n```\n\n---\n\n## Trust Chain & Endorsements\n\nAgents can be endorsed by trusted parties to build reputation.\n\n```json\n{\n  \"trust_chain\": [\n    {\n      \"issuer\": \"did:web:verified-agents.example.com\",\n      \"issued_at\": 1707244800,\n      \"expires_at\": 1708849600,\n      \"trust_level\": \"verified\",\n      \"signature\": \"jws_signature_of_endorsement\"\n    }\n  ]\n}\n```\n\n**Trust Levels:**\n- `self` — Agent's own manifest (always trusted if signature verifies)\n- `verified` — Endorsed by a trusted registry or organization\n- `delegated` — Endorsed by another agent with delegated authority\n\n---\n\n## Manifest Caching & Pinning\n\n### Recommended Cache TTL\n- DNS-based discovery: 1 hour\n- GitHub-based discovery: 6 hours\n- Direct URL: 24 hours\n\n### Pinning\nClients SHOULD support manifest pinning to prevent MITM attacks:\n\n```json\n{\n  \"pinned_manifests\": {\n    \"did:key:z6Mk...\": \"sha256:manifest_hash\",\n    \"did:web:example.com\": \"sha256:manifest_hash\"\n  }\n}\n```\n\nIf fetched manifest hash doesn't match pinned hash, reject with error.\n\n---\n\n**Agent Identity & Manifest v1.0 — Cryptographic foundation for agent trust.**\n"
          }
</invoke>