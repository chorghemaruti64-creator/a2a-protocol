# A2A Security Model (v1.0)\n\n## Threat Model\n\n### Actors\n\n**Trusted:**\n- Agent A (client) â€” We control and trust\n- Agent B (server) â€” We're connecting to\n\n**Untrusted:**\n- Network attacker â€” Can intercept, modify, replay messages\n- Rogue agent â€” Claims to be Agent B but isn't\n- Malicious service operator â€” Runs servers or registries\n\n### Attack Scenarios\n\n#### 1. Impersonation\n**Threat:** Attacker claims to be Agent B\n\n**Mitigations:**\n- âœ… TLS certificate verification (prevents DNS hijacking)\n- âœ… Manifest signature verification (cryptographic proof)\n- âœ… DID binding (public key embedded in identifier)\n\n**Result:** Attacker cannot forge valid manifest without Agent B's private key\n\n#### 2. Man-in-the-Middle (MITM)\n**Threat:** Attacker intercepts and modifies messages\n\n**Mitigations:**\n- âœ… TLS 1.3 mandatory (encryption + authentication)\n- âœ… Forward secrecy (ephemeral keys for session)\n- âœ… Message signatures (JWS on all protocol messages)\n\n**Result:** Attacker cannot read or modify encrypted traffic\n\n#### 3. Replay Attacks\n**Threat:** Attacker replays old messages\n\n**Mitigations:**\n- âœ… Nonce binding in handshake (unique per connection)\n- âœ… Request IDs in session (detect duplicate requests)\n- âœ… Timestamps (reject messages >5 min old)\n- âœ… Server state tracking (reject reused session IDs)\n\n**Result:** Attacker cannot replay old sessions or requests\n\n#### 4. Message Tampering\n**Threat:** Attacker modifies message content\n\n**Mitigations:**\n- âœ… JWS signatures on all messages (integrity protection)\n- âœ… HMAC-like binding (message signed with sender's key)\n- âœ… TLS (additional transport-layer integrity)\n\n**Result:** Attacker cannot modify messages without detection\n\n#### 5. Policy Bypass\n**Threat:** Client ignores server's policy (rate limit, etc.)\n\n**Mitigations:**\n- âœ… Server-side enforcement (policy applied server, not client)\n- âœ… Signed policy agreement (client acknowledges policy)\n- âœ… Audit logging (violations logged and detectable)\n\n**Result:** Server protects itself regardless of client behavior\n\n#### 6. Rate Limit Abuse\n**Threat:** Attacker sends unlimited requests\n\n**Mitigations:**\n- âœ… Token bucket rate limiter (server-enforced)\n- âœ… Per-session limits (not per-IP)\n- âœ… Quota tracking (across time windows)\n\n**Result:** Server cannot be overwhelmed past rate limit\n\n#### 7. Manifest Poisoning\n**Threat:** Attacker provides outdated/revoked manifest\n\n**Mitigations:**\n- âœ… Manifest pinning (hash verification)\n- âœ… Signature verification (detect tampering)\n- âœ… Expiry checking (reject expired manifests)\n- âœ… Cache invalidation on signature failure\n\n**Result:** Attacker cannot use old manifests\n\n#### 8. Key Compromise\n**Threat:** Attacker obtains an agent's private key\n\n**Mitigations:**\n- âœ… Key rotation support (new keys in manifest)\n- âœ… Grace period (accept both old and new keys)\n- âœ… Server-side enforcement (can disable bad keys)\n- âš ï¸ Limited (no immediate revocation mechanism in v1.0)\n\n**Result:** Key rotation can limit damage, but no immediate revocation\n\n---\n\n## Trust Model\n\n### Trust Signals (in preference order)\n\n1. **Self-Signed Identity**\n   - Level: `self`\n   - Crypto binding: DID derived from public key\n   - Verification: Manifest signature with matching key\n   - Usability: Sufficient for untrusted agent networks\n\n2. **Verified by Registry**\n   - Level: `verified`\n   - Source: Trusted registry or organization signs endorsement\n   - Verification: Check registry's signature over agent's manifest\n   - Usability: Required for production networks\n   - Examples: Anthropic-endorsed agents, vetted agent libraries\n\n3. **Delegated Authority**\n   - Level: `delegated`\n   - Source: Agent A endorses Agent B (transitive trust)\n   - Verification: Check A's signature over B's endorsement\n   - Usability: Social graph for reputation\n   - Examples: \"Company X uses Agent Y\"\n\n4. **Unverified**\n   - Level: `unverified`\n   - Source: No trust chain present\n   - Usability: Manual review required, high risk\n   - Examples: New agents, unknown sources\n\n### Trust Decision Tree\n\n```\nAgent manifest discovered\n    â”‚\n    â”œâ”€ Signature valid?\n    â”‚   â”œâ”€ NO â†’ trust_level = UNVERIFIED âš ï¸\n    â”‚   â”‚       (can connect with user override only)\n    â”‚   â”‚\n    â”‚   â””â”€ YES â†’ Continue\n    â”‚\n    â”œâ”€ Has trust_chain?\n    â”‚   â”œâ”€ YES â†’ Verify each chain signature\n    â”‚   â”‚         â”‚\n    â”‚   â”‚         â”œâ”€ All valid? â†’ trust_level = VERIFIED âœ…\n    â”‚   â”‚         â””â”€ Some invalid? â†’ trust_level = PARTIAL âš ï¸\n    â”‚   â”‚\n    â”‚   â””â”€ NO â†’ trust_level = SIGNED ğŸ”’\n    â”‚\n    â””â”€ Manifest expired?\n        â”œâ”€ YES â†’ REJECT (refuse to connect) âŒ\n        â””â”€ NO â†’ Proceed with trust_level from above\n```\n\n### Trust Anchors\n\nOrganizations should maintain trust anchors:\n\n```json\n{\n  \"trust_anchors\": {\n    \"anthropic\": {\n      \"did\": \"did:web:anthropic.com\",\n      \"public_key\": \"base64url...\",\n      \"min_trust_level\": \"delegated\"\n    },\n    \"openai\": {\n      \"did\": \"did:web:openai.com\",\n      \"public_key\": \"base64url...\",\n      \"min_trust_level\": \"delegated\"\n    }\n  }\n}\n```\n\n---\n\n## Cryptographic Standards\n\n### Required (v1.0)\n\n- **EdDSA** (Ed25519) â€” Agent signing, all JWS\n- **SHA-256** â€” Manifest and policy hashing\n- **TLS 1.3** â€” Transport encryption (mandatory)\n- **JWS (JSON Web Signature)** â€” Message authentication\n\n### Optional (v1.0, may be required in v1.1)\n\n- **ChaCha20-Poly1305** â€” Application-layer encryption\n- **ECDH** (Curve25519) â€” Shared secret derivation\n- **HKDF** â€” Key derivation\n\n### Not Allowed\n\n- âŒ RSA (too slow)\n- âŒ ECDSA (malleability issues)\n- âŒ MD5, SHA-1 (cryptographically broken)\n- âŒ AES without authenticated encryption\n- âŒ Custom crypto\n\n---\n\n## Key Management\n\n### Key Generation\n\n```python\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\n\nprivate_key = ed25519.Ed25519PrivateKey.generate()  # Cryptographically secure\npublic_key = private_key.public_key()\n```\n\n**Requirements:**\n- Use OS-provided RNG (not custom)\n- Store private key securely (encrypted at rest, in memory only when needed)\n- Never log private key material\n- Rotate regularly (recommend every 1 year)\n\n### Key Rotation\n\nWhen compromised or aged:\n\n```json\n{\n  \"public_keys\": [\n    {\n      \"kid\": \"sig-2024-01\",\n      \"key\": \"base64url_new_key\",\n      \"status\": \"active\"\n    },\n    {\n      \"kid\": \"sig-2023-01\",\n      \"key\": \"base64url_old_key\",\n      \"status\": \"deprecated\",\n      \"expires_at\": 1707244800\n    }\n  ]\n}\n```\n\n**Grace period:** 24 hours minimum (allow clients to cache the old key)\n\n---\n\n## TLS Requirements\n\n### Minimum Version\n\n- âœ… TLS 1.3 (required)\n- âš ï¸ TLS 1.2 with specific ciphers (transitional, not recommended)\n- âŒ TLS 1.1 or older (not allowed)\n\n### Cipher Suites (TLS 1.3)\n\n- `TLS_AES_256_GCM_SHA384`\n- `TLS_CHACHA20_POLY1305_SHA256`\n- `TLS_AES_128_GCM_SHA256` (acceptable)\n\n### Certificate Validation\n\n1. âœ… Verify certificate chain\n2. âœ… Verify hostname matches\n3. âœ… Check certificate not expired\n4. âœ… Verify certificate is trusted\n5. âœ… Require forward secrecy (DHE or ECDHE)\n\n### OCSP Stapling\n\nRecommended for production (validate certificate revocation).\n\n---\n\n## Audit Logging\n\n### What to Log\n\nEvery A2A interaction should produce audit log entries:\n\n```json\n{\n  \"timestamp\": \"2026-02-07T15:00:00.000Z\",\n  \"event_type\": \"a2a_request_received\",\n  \"request_id\": \"uuid-correlation-id\",\n  \"session_id\": \"session_id\",\n  \"remote_agent_did\": \"did:key:z6Mk...\",\n  \"remote_ip\": \"203.0.113.42\",\n  \"intent\": {\n    \"goal\": \"translate\",\n    \"domain\": \"nlp\"\n  },\n  \"policy_checks\": {\n    \"session_valid\": true,\n    \"rate_limit\": \"passed\",\n    \"intent_allowed\": true,\n    \"signature_verified\": true,\n    \"payload_size_ok\": true\n  },\n  \"enforcement_actions\": [],\n  \"result\": \"APPROVED\",\n  \"response_status\": \"success\",\n  \"processing_time_ms\": 234,\n  \"notes\": \"Routine request\"\n}\n```\n\n### Logging to Output\n\n```python\nimport json\nimport logging\n\nlogger = logging.getLogger(\"a2a\")\n\naudit_entry = {\n    \"timestamp\": datetime.utcnow().isoformat() + \"Z\",\n    \"event_type\": \"a2a_request_received\",\n    \"request_id\": request_id,\n    # ... other fields\n}\n\nlogger.info(json.dumps(audit_entry))\n```\n\n### Retention\n\n- **Policy-specified:** Respect `data_retention` from agent's policy\n- **Minimum:** 7 days (for incident investigation)\n- **Recommended:** 90 days (for compliance)\n- **Sensitive:** Delete PII after retention period\n\n---\n\n## Deployment Security Checklist\n\n- [ ] TLS 1.3 enforced (reject non-TLS connections)\n- [ ] Server certificate valid and trusted\n- [ ] OCSP stapling enabled (if supported)\n- [ ] Private keys encrypted at rest\n- [ ] Private keys never logged or exposed\n- [ ] Audit logging enabled\n- [ ] Rate limiting enforced server-side\n- [ ] Manifest signature verification enabled\n- [ ] Policy enforcement configured\n- [ ] Firewall rules restrict network access\n- [ ] Regular security updates (TLS, dependencies)\n- [ ] Key rotation plan documented\n- [ ] Incident response plan written\n- [ ] Security contact (mailto:security@...)\n\n---\n\n**A2A Security Model v1.0 â€” Defense in depth for agent networks.**\n"
          }
</invoke>