\"\"\"\nAgent identity and cryptographic key management.\n\nDefines:\n- DID (Decentralized Identifier) resolution\n- Agent manifest and metadata\n- KeyPair generation and management\n\"\"\"\n\nfrom dataclasses import dataclass, field\nfrom typing import Optional, List, Dict, Any\nfrom enum import Enum\nimport json\nimport hashlib\nimport base64\nimport time\nfrom abc import ABC, abstractmethod\n\n\nclass DIDMethod(Enum):\n    \"\"\"Supported DID resolution methods.\"\"\"\n    KEY = \"key\"        # did:key:z6Mk... (self-signed)\n    WEB = \"web\"        # did:web:example.com (DNS-backed)\n    GITHUB = \"github\"  # did:github:owner/repo (GitHub-backed)\n\n\nclass DID:\n    \"\"\"\n    Decentralized Identifier for an agent.\n    \n    Formats:\n    - did:key:z6Mk...      (public key embedded)\n    - did:web:example.com  (DNS resolution)\n    - did:github:owner/repo (GitHub resolution)\n    \"\"\"\n    \n    def __init__(self, did_string: str):\n        self.did = did_string\n        self.method = self._extract_method()\n        self.identifier = self._extract_identifier()\n    \n    def _extract_method(self) -> DIDMethod:\n        \"\"\"Extract DID method from string.\"\"\"\n        if not self.did.startswith(\"did:\"):\n            raise ValueError(f\"Invalid DID format: {self.did}\")\n        method_str = self.did.split(\":\")[1]\n        return DIDMethod(method_str)\n    \n    def _extract_identifier(self) -> str:\n        \"\"\"Extract identifier portion.\"\"\"\n        return self.did.split(\":\", 2)[2]\n    \n    def __str__(self) -> str:\n        return self.did\n    \n    def __eq__(self, other) -> bool:\n        return self.did == str(other)\n    \n    def __hash__(self) -> int:\n        return hash(self.did)\n\n\n@dataclass\nclass PublicKey:\n    \"\"\"JWK-format public key for agent.\"\"\"\n    kid: str              # Key identifier (for rotation)\n    kty: str              # Key type (\"EC\" for EdDSA)\n    alg: str              # Algorithm (\"EdDSA\")\n    use: str              # Use case (\"sig\" for signature)\n    key: str              # Base64url-encoded key material\n    \n    def to_dict(self) -> Dict[str, str]:\n        return {\n            \"kid\": self.kid,\n            \"kty\": self.kty,\n            \"alg\": self.alg,\n            \"use\": self.use,\n            \"key\": self.key,\n        }\n\n\n@dataclass\nclass AgentManifest:\n    \"\"\"\n    Signed identity card for an agent.\n    \n    See: /spec/AGENT_IDENTITY.md\n    \"\"\"\n    manifest_version: str\n    agent_did: str\n    agent_id: str\n    public_keys: List[PublicKey]\n    endpoints: List[Dict[str, Any]]\n    capabilities: List[Dict[str, Any]] = field(default_factory=list)\n    policy: Optional[Dict[str, Any]] = None\n    trust_chain: List[Dict[str, Any]] = field(default_factory=list)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    published_at: int = field(default_factory=lambda: int(time.time()))\n    expires_at: Optional[int] = None\n    manifest_hash: Optional[str] = None\n    manifest_signature: Optional[str] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to JSON-serializable dict.\"\"\"\n        return {\n            \"manifest_version\": self.manifest_version,\n            \"agent_did\": self.agent_did,\n            \"agent_id\": self.agent_id,\n            \"public_keys\": [pk.to_dict() for pk in self.public_keys],\n            \"endpoints\": self.endpoints,\n            \"capabilities\": self.capabilities,\n            \"policy\": self.policy,\n            \"trust_chain\": self.trust_chain,\n            \"metadata\": self.metadata,\n            \"published_at\": self.published_at,\n            \"expires_at\": self.expires_at,\n            \"manifest_hash\": self.manifest_hash,\n            \"manifest_signature\": self.manifest_signature,\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> \"AgentManifest\":\n        \"\"\"Create from JSON dict.\"\"\"\n        public_keys = [\n            PublicKey(**pk) for pk in data.get(\"public_keys\", [])\n        ]\n        return cls(\n            manifest_version=data[\"manifest_version\"],\n            agent_did=data[\"agent_did\"],\n            agent_id=data[\"agent_id\"],\n            public_keys=public_keys,\n            endpoints=data[\"endpoints\"],\n            capabilities=data.get(\"capabilities\", []),\n            policy=data.get(\"policy\"),\n            trust_chain=data.get(\"trust_chain\", []),\n            metadata=data.get(\"metadata\", {}),\n            published_at=data.get(\"published_at\", int(time.time())),\n            expires_at=data.get(\"expires_at\"),\n            manifest_hash=data.get(\"manifest_hash\"),\n            manifest_signature=data.get(\"manifest_signature\"),\n        )\n\n\nclass KeyPair:\n    \"\"\"\n    EdDSA (Ed25519) keypair for agent signing.\n    \"\"\"\n    \n    def __init__(self, private_key_bytes: bytes, public_key_bytes: bytes):\n        \"\"\"Initialize with raw key bytes.\"\"\"\n        self.private_key_bytes = private_key_bytes\n        self.public_key_bytes = public_key_bytes\n    \n    @staticmethod\n    def generate() -> \"KeyPair\":\n        \"\"\"\n        Generate a new Ed25519 keypair.\n        \n        Returns:\n            KeyPair: New keypair\n        \"\"\"\n        # TODO: Implement with cryptography library\n        raise NotImplementedError(\"See reference implementation\")\n    \n    @staticmethod\n    def from_private_key_base64(key_b64: str) -> \"KeyPair\":\n        \"\"\"\n        Load keypair from base64url-encoded private key.\n        \n        Args:\n            key_b64: Base64url-encoded private key\n        \n        Returns:\n            KeyPair: Loaded keypair\n        \"\"\"\n        # TODO: Implement\n        raise NotImplementedError(\"See reference implementation\")\n    \n    def private_key_base64(self) -> str:\n        \"\"\"Get private key as base64url string.\"\"\"\n        return base64.urlsafe_b64encode(self.private_key_bytes).decode().rstrip(\"=\")\n    \n    def public_key_base64(self) -> str:\n        \"\"\"Get public key as base64url string.\"\"\"\n        return base64.urlsafe_b64encode(self.public_key_bytes).decode().rstrip(\"=\")\n    \n    def get_did(self) -> DID:\n        \"\"\"\n        Derive did:key from public key.\n        \n        Returns:\n            DID: did:key:z6Mk...\n        \"\"\"\n        # TODO: Implement multicodec encoding\n        raise NotImplementedError(\"See reference implementation\")\n    \n    def sign(self, message: bytes) -> bytes:\n        \"\"\"\n        Sign a message with private key.\n        \n        Args:\n            message: Message bytes\n        \n        Returns:\n            bytes: Signature\n        \"\"\"\n        # TODO: Implement EdDSA signing\n        raise NotImplementedError(\"See reference implementation\")\n    \n    def verify(self, message: bytes, signature: bytes) -> bool:\n        \"\"\"\n        Verify a signature with public key.\n        \n        Args:\n            message: Message bytes\n            signature: Signature bytes\n        \n        Returns:\n            bool: True if valid\n        \"\"\"\n        # TODO: Implement EdDSA verification\n        raise NotImplementedError(\"See reference implementation\")\n\n\nclass AgentIdentity:\n    \"\"\"\n    An agent's cryptographic identity.\n    \n    Binds together:\n    - DID (Decentralized Identifier)\n    - Public keys (for verification)\n    - Manifest (signed claim of identity)\n    \"\"\"\n    \n    def __init__(\n        self,\n        did: DID,\n        manifest: AgentManifest,\n        keypair: Optional[KeyPair] = None,\n    ):\n        self.did = did\n        self.manifest = manifest\n        self.keypair = keypair  # None if remote agent\n    \n    @staticmethod\n    def from_did(did_string: str) -> \"AgentIdentity\":\n        \"\"\"\n        Resolve agent identity from DID.\n        \n        Fetches and verifies manifest based on DID method.\n        \n        Args:\n            did_string: DID string\n        \n        Returns:\n            AgentIdentity: Resolved identity\n        \n        Raises:\n            UnverifiedAgentError: If manifest cannot be verified\n        \"\"\"\n        # TODO: Implement DID resolution\n        raise NotImplementedError(\"See reference implementation\")\n    \n    @staticmethod\n    def create(keypair: KeyPair, agent_id: str) -> \"AgentIdentity\":\n        \"\"\"\n        Create a new agent identity.\n        \n        Args:\n            keypair: Agent's keypair\n            agent_id: Human-readable agent ID\n        \n        Returns:\n            AgentIdentity: New identity\n        \"\"\"\n        # TODO: Implement\n        raise NotImplementedError(\"See reference implementation\")\n    \n    def sign_manifest(self) -> str:\n        \"\"\"\n        Sign the agent's manifest.\n        \n        Returns:\n            str: JWS signature\n        \"\"\"\n        if not self.keypair:\n            raise RuntimeError(\"Cannot sign without private key\")\n        # TODO: Implement JWS signing\n        raise NotImplementedError(\"See reference implementation\")\n    \n    def verify_manifest(self) -> bool:\n        \"\"\"\n        Verify this agent's manifest signature.\n        \n        Returns:\n            bool: True if valid\n        \"\"\"\n        # TODO: Implement verification\n        raise NotImplementedError(\"See reference implementation\")\n\n\nclass Agent:\n    \"\"\"\n    High-level A2A Agent API.\n    \n    Usage:\n        >>> agent = Agent.from_keypair(keypair, \"my-agent\")\n        >>> session = await agent.connect(\"did:key:z6Mk...\")\n        >>> result = await session.send(Intent(...))\n    \"\"\"\n    \n    def __init__(self, identity: AgentIdentity):\n        self.identity = identity\n    \n    @staticmethod\n    def from_keypair(keypair: KeyPair, agent_id: str) -> \"Agent\":\n        \"\"\"\n        Create agent from keypair.\n        \n        Args:\n            keypair: Agent's keypair\n            agent_id: Human-readable ID\n        \n        Returns:\n            Agent: New agent\n        \"\"\"\n        # TODO: Implement\n        raise NotImplementedError(\"See reference implementation\")\n    \n    async def connect(self, remote_did: str):\n        \"\"\"\n        Connect to another agent.\n        \n        Args:\n            remote_did: DID of remote agent\n        \n        Returns:\n            Session: Authenticated session\n        \n        Raises:\n            UnverifiedAgentError: If remote agent cannot be verified\n            HandshakeError: If handshake fails\n        \"\"\"\n        # TODO: Implement connection flow\n        raise NotImplementedError(\"See reference implementation\")\n"
          }
</invoke>
