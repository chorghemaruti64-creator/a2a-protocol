# A2A Reference Architecture\n\n## Layered Design\n\nA2A Protocol uses a **clean layered architecture** for separation of concerns and testability:\n\n```\n┌─────────────────────────────────────────────────────┐\n│ APPLICATION LAYER                                   │\n│ (Agent implementation, business logic)              │\n└────────────────────┬────────────────────────────────┘\n                     │\n┌────────────────────▼────────────────────────────────┐\n│ A2A PROTOCOL LAYER                                  │\n│                                                     │\n│ ┌─────────────────────────────────────────────┐   │\n│ │ Identity & Discovery                        │   │\n│ │ - DIDs (did:key, did:web, did:github)      │   │\n│ │ - Manifest resolution                       │   │\n│ │ - Signature verification                    │   │\n│ └─────────────────────────────────────────────┘   │\n│                                                     │\n│ ┌─────────────────────────────────────────────┐   │\n│ │ Handshake FSM                               │   │\n│ │ - HELLO, CHALLENGE, PROOF, POLICY, SESSION │   │\n│ │ - Nonce binding                             │   │\n│ │ - Timeout handling                          │   │\n│ └─────────────────────────────────────────────┘   │\n│                                                     │\n│ ┌─────────────────────────────────────────────┐   │\n│ │ Session Management                          │   │\n│ │ - Request/response lifecycle                │   │\n│ │ - Message ordering (counter)                │   │\n│ │ - Expiry and cleanup                        │   │\n│ └─────────────────────────────────────────────┘   │\n│                                                     │\n│ ┌─────────────────────────────────────────────┐   │\n│ │ Policy & Security                           │   │\n│ │ - Policy enforcement (rate limit, filters)  │   │\n│ │ - JWS signature verification                │   │\n│ │ - Audit logging                             │   │\n│ └─────────────────────────────────────────────┘   │\n└────────────────────┬────────────────────────────────┘\n                     │\n┌────────────────────▼────────────────────────────────┐\n│ TRANSPORT ABSTRACTION LAYER (TAL)                   │\n│                                                     │\n│ Pluggable transports (all require TLS 1.3):        │\n│ - HTTP/1.1 (reference)                             │\n│ - HTTP/2 with gRPC (optional)                      │\n│ - WebSocket (optional)                             │\n│ - Custom (provided by users)                       │\n└────────────────────┬────────────────────────────────┘\n                     │\n┌────────────────────▼────────────────────────────────┐\n│ NETWORK LAYER                                       │\n│ (TLS 1.3 encryption, authentication, integrity)    │\n└─────────────────────────────────────────────────────┘\n```\n\n## Module Organization\n\n### Core (`a2a/core/`)\n\n**Purpose:** Foundational types, errors, and utilities\n\n- `identity.py` — DID, Agent, KeyPair types\n- `errors.py` — Standard error codes and exceptions\n- `types.py` — Common types (SessionID, IntentID, etc.)\n- `fsm.py` — Base state machine class\n\n**Invariant:** No dependencies on protocol or transport layers\n\n### Protocol (`a2a/protocol/`)\n\n**Purpose:** A2A protocol implementation (all FSMs)\n\n#### Handshake (`protocol/handshake/`)\n- `fsm.py` — Handshake state machine\n- `messages.py` — HELLO, CHALLENGE, PROOF, etc. (Pydantic models)\n- `verification.py` — Signature verification\n\n#### Discovery (`protocol/discovery/`)\n- `fsm.py` — Discovery flow\n- `backends.py` — DID resolution backends (did:key, did:web, did:github)\n- `cache.py` — Manifest caching\n\n#### Session (`protocol/session/`)\n- `fsm.py` — Session lifecycle FSM\n- `manager.py` — Session pool\n- `messages.py` — Intent, Result types\n\n#### Verification (`protocol/verification/`)\n- `manifest.py` — Manifest validation\n- `signatures.py` — JWS verification\n- `trust.py` — Trust chain evaluation\n\n**Invariant:** Protocol logic is independent of transport\n\n### Transport (`a2a/transport/`)\n\n**Purpose:** Pluggable transport implementations\n\n- `base.py` — Transport ABC (abstract base class)\n- `http.py` — HTTP/1.1 + 2 implementation\n- `adapters/` — gRPC, WebSocket, custom implementations\n\n**Invariant:** Transport is opaque to protocol\n\n### Security (`a2a/security/`)\n\n**Purpose:** Cryptographic operations and policy enforcement\n\n- `crypto.py` — EdDSA, JWS, hashing utilities\n- `policy.py` — Policy definition and enforcement\n- `audit.py` — Structured audit logging\n\n**Invariant:** All crypto operations centralized\n\n### Configuration (`a2a/config/`)\n\n**Purpose:** Validation and loading of configuration\n\n- `schema.py` — Pydantic models for AgentConfig, PolicyConfig, etc.\n- `loader.py` — File-based config loading\n\n**Invariant:** All configuration validated with Pydantic\n\n## Data Flow: End-to-End Agent Call\n\n```\n┌─────────────────────────────────────────────────────────┐\n│ Agent A (Client)                                        │\n└─────────────────────────────────────────────────────────┘\n                         │\n                         │ 1. agent.connect(\"did:web:...\")\n                         v\n                 ┌───────────────┐\n                 │ Discovery FSM │  \n                 └───────────────┘\n                    1.1 Resolve DID → https://example.com\n                    1.2 Fetch manifest\n                    1.3 Verify signature\n                    1.4 Cache locally\n                         │\n                         v\n                 ┌───────────────┐\n                 │ Handshake FSM │\n                 └───────────────┘\n                    2.1 Create HELLO\n                    2.2 Send via Transport layer (TLS)\n                    2.3 Receive CHALLENGE\n                    2.4 Create PROOF (sign nonces)\n                    2.5 Send PROOF\n                    2.6 Receive POLICY\n                    2.7 Accept POLICY\n                    2.8 Receive SESSION\n                         │\n                         v\n                 ┌───────────────┐\n                 │ Session FSM   │\n                 └───────────────┘\n                    3.1 session.send(Intent(\n                            goal=\"translate\",\n                            inputs={...}\n                        ))\n                    3.2 Create REQUEST\n                    3.3 Sign with JWS\n                    3.4 Send via Transport (TLS)\n                    3.5 Receive RESPONSE\n                    3.6 Verify signature\n                    3.7 Return result\n                         │\n                         v\n         Result: {\"translated_text\": \"...\"}\n\n\n┌─────────────────────────────────────────────────────────┐\n│ Agent B (Server)                                        │\n└─────────────────────────────────────────────────────────┘\n                         ▲\n                         │\n                    ← Receive HELLO\n                    1. Load agent manifest\n                    2. Create CHALLENGE\n                    3. Send CHALLENGE\n                         │\n                    ← Receive PROOF  \n                    4. Verify nonce binding\n                    5. Verify signature\n                    6. Load policy\n                    7. Create POLICY\n                    8. Send POLICY\n                         │\n                    ← Receive ACCEPT_POLICY\n                    9. Verify acceptance signature\n                   10. Create SESSION\n                   11. Send SESSION\n                        │\n                   ← Receive REQUEST\n                   12. Verify session (not expired)\n                   13. Verify request signature\n                   14. Enforce rate limit\n                   15. Filter by allowed/blocked intents\n                   16. Execute intent\n                   17. Create RESPONSE\n                   18. Sign with JWS\n                   19. Send RESPONSE\n                   20. Log audit entry\n```\n\n## Component Interactions\n\n### Discovery + Identity\n\n```\nClient wants to reach Agent B\n    │\n    ├─ agent.connect(identifier=\"did:web:example.com\")\n    │\n    ├─ Discovery.resolve(identifier)\n    │   ├─ For did:web:\n    │   │   └─ HTTPS GET https://example.com/.well-known/did.json\n    │   ├─ For did:github:\n    │   │   └─ GitHub API + raw.githubusercontent.com\n    │   └─ For did:key:\n    │       └─ Extract from DID directly (no network)\n    │\n    ├─ Verification.verify_manifest(manifest)\n    │   ├─ Check timestamp recent\n    │   ├─ Resolve public key from DID\n    │   ├─ Verify JWS signature\n    │   └─ Check expiry\n    │\n    └─ If valid → proceed to handshake\n       If invalid → reject with error\n```\n\n### Handshake + Policy\n\n```\nHandshake FSM running\n    │\n    ├─ HELLO sent\n    ├─ CHALLENGE received\n    │   └─ Nonces bound for proof\n    ├─ PROOF sent (sign nonces)\n    ├─ POLICY received (server's constraints)\n    │\n    ├─ Policy evaluation:\n    │   ├─ Is rate limit acceptable?\n    │   ├─ Is session timeout acceptable?\n    │   ├─ Is max payload size acceptable?\n    │   └─ Are required capabilities present?\n    │\n    ├─ If policy acceptable → ACCEPT_POLICY\n    └─ If not → disconnect\n```\n\n### Session + Audit Logging\n\n```\nIncoming REQUEST\n    │\n    ├─ Verify session not expired\n    ├─ Verify request signature\n    ├─ Check rate limit (server-side)\n    ├─ Filter by allowed/blocked intents\n    ├─ Validate payload size\n    │\n    ├─ Log audit entry:\n    │   {\n    │     event_type: \"request_received\",\n    │     request_id: ...,\n    │     session_id: ...,\n    │     remote_agent_did: ...,\n    │     policy_checks: {...},\n    │     result: \"APPROVED\",\n    │     processing_time_ms: ...\n    │   }\n    │\n    ├─ Execute intent\n    ├─ Create RESPONSE\n    └─ Send response\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n- FSM state transitions\n- Crypto operations (sign/verify)\n- Policy parsing and validation\n- Error code mappings\n\n**Location:** `tests/unit/`\n\n### Integration Tests\n\n- Full handshake flow (hello → challenge → proof → policy → session)\n- Request/response cycle\n- Policy enforcement\n- Error recovery\n\n**Location:** `tests/integration/`\n\n### Protocol Compliance Tests\n\n- Message format validation\n- Nonce binding\n- Signature verification\n- Timeout behavior\n\n**Location:** `tests/compliance/`\n\n### End-to-End Tests\n\n- Two agents connecting\n- Full intent execution\n- Policy violations\n- Edge cases (expired session, rate limit, etc.)\n\n**Location:** `tests/fixtures/` for test agents\n\n## Error Handling\n\nAll errors propagate as `A2AError` with:\n- Standard error code\n- Human-readable message\n- Recoverable flag\n- Request ID for correlation\n\n```python\nclass A2AError(Exception):\n    code: str                    # \"RATE_LIMIT_EXCEEDED\"\n    message: str                 # \"Rate limit: 1000 per 3600s\"\n    details: dict                # {\"current\": 1050, \"limit\": 1000}\n    recoverable: bool            # True = can retry\n    request_id: str              # For logging\n```\n\n## Configuration\n\nAll components configured via:\n\n```python\nfrom a2a.config.schema import AgentConfig, PolicyConfig\n\nconfig = AgentConfig(\n    agent_id=\"my-agent\",\n    private_key_base64=\"...\",\n    server_port=8000,\n    policy=PolicyConfig(\n        rate_limit=1000,\n        rate_period=3600,\n        session_timeout=3600,\n        data_retention=\"24h\"\n    )\n)\n```\n\nAll configurations validated with Pydantic (type-safe, JSON schema export).\n\n---\n\n**A2A Reference Architecture — Clean, layered, testable, extensible.**\n"
          }
</invoke>
